import React, { useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import MenuElement, { MenuElementProps } from '../MenuElement';
import { onGenericKeyDown, Direction, menuTopElementHorizontalEvent, menuTopElementSwitchEvent, } from '../const';
import PolyEvent from '../../../polyfill/Event';
const MenuTopElement = (props) => {
    var _a;
    const { menu, tabIndex, changeMenuIndex, currentMenuIndex, } = props;
    const selfRef = useRef(null);
    // Horizontal move from sub-element
    useEffect(() => {
        if (!selfRef.current) {
            return () => { };
        }
        const myself = selfRef.current;
        const listener = (event) => {
            var _a;
            const { direction } = event.detail;
            const target = direction === Direction.Right ? myself.nextSibling : myself.previousSibling;
            (_a = target) === null || _a === void 0 ? void 0 : _a.focus();
        };
        myself.addEventListener(menuTopElementHorizontalEvent, listener);
        return () => {
            myself.removeEventListener(menuTopElementHorizontalEvent, listener);
        };
    }, [selfRef]);
    const onClick = (event) => {
        const target = event.target;
        if (target !== selfRef.current
            || !target.classList.contains('MenuItem')) {
            return;
        }
        if (tabIndex === currentMenuIndex) {
            changeMenuIndex(-1);
            return;
        }
        selfRef.current.focus();
        changeMenuIndex(tabIndex);
    };
    const onMouseEnter = () => {
        var _a;
        if (currentMenuIndex === -1 || tabIndex === currentMenuIndex) {
            return;
        }
        changeMenuIndex(tabIndex);
        const topParent = (_a = selfRef.current) === null || _a === void 0 ? void 0 : _a.closest('.MenuBar');
        if (topParent) {
            topParent.dispatchEvent(PolyEvent(menuTopElementSwitchEvent));
        }
    };
    const onKeyDown = onGenericKeyDown((direction) => {
        if (document.activeElement !== selfRef.current) {
            return;
        }
        const htmlElement = selfRef.current;
        const sibling = direction === Direction.Right ? htmlElement.nextSibling : htmlElement.previousSibling;
        if (!sibling) {
            return;
        }
        sibling.focus();
        changeMenuIndex(sibling.tabIndex);
    }, (direction) => {
        var _a;
        if (direction === Direction.Up
            || !selfRef.current
            || document.activeElement !== selfRef.current) {
            return;
        }
        const target = document.querySelector('.MenuItem.open .MenuElement');
        (_a = target) === null || _a === void 0 ? void 0 : _a.focus();
    });
    return (React.createElement("div", { tabIndex: tabIndex, "data-name": menu.name, className: classnames('MenuItem', { open: tabIndex === currentMenuIndex }), onClick: onClick, onMouseEnter: onMouseEnter, onFocus: onMouseEnter, onKeyDown: onKeyDown, role: "menu", ref: selfRef },
        menu.name,
        React.createElement("div", { className: classnames('MenuElements', { open: tabIndex === currentMenuIndex }) }, (_a = menu.elements) === null || _a === void 0 ? void 0 : _a.map((element, elementIndex) => (React.createElement(MenuElement, { key: element.name, tabIndex: elementIndex, element: element, parentPath: menu.name }))))));
};
export const MenuItemProps = PropTypes.shape({
    name: PropTypes.string.isRequired,
    elements: PropTypes.arrayOf(MenuElementProps),
});
MenuTopElement.propTypes = {
    tabIndex: PropTypes.number.isRequired,
    currentMenuIndex: PropTypes.number.isRequired,
    menu: MenuItemProps.isRequired,
    changeMenuIndex: PropTypes.func.isRequired,
};
export default MenuTopElement;
//# sourceMappingURL=index.js.map