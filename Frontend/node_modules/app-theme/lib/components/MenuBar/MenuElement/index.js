import React, { useState, useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import { MdKeyboardArrowRight, MdCheck } from 'react-icons/md';
import { menuCloseEvent, menuElementMouseEnterEvent, onGenericKeyDown, Direction, menuTopElementHorizontalEvent, menuTopElementSwitchEvent, } from '../const';
import PolyCustomEvent from '../../../polyfill/CustomEvent';
const checkElementNotContainedBy = (elem, container) => {
    if (!container) {
        return false;
    }
    if (elem === container) {
        return true;
    }
    const parent = elem.parentElement;
    return !parent ? false : checkElementNotContainedBy(parent, container);
};
const MenuElement = (props) => {
    var _a, _b;
    const { onClick: onOuterClick, element, parentPath, tabIndex, } = props;
    const { onClick, isSeparator } = element;
    const [isOpen, setOpen] = useState(false);
    const [closeTimeout, setCloseTimeout] = useState(-1);
    const selfRef = useRef(null);
    const ownPath = `${parentPath}.${element.name}`;
    useEffect(() => {
        var _a, _b;
        if (!selfRef.current || !((_a = element.subElements) === null || _a === void 0 ? void 0 : _a.length)) {
            return () => { };
        }
        const onTopMenuSwtich = () => {
            setOpen(false);
        };
        const topParent = selfRef.current.closest('.MenuBar');
        (_b = topParent) === null || _b === void 0 ? void 0 : _b.addEventListener(menuTopElementSwitchEvent, onTopMenuSwtich);
        return () => {
            var _a;
            (_a = topParent) === null || _a === void 0 ? void 0 : _a.removeEventListener(menuTopElementSwitchEvent, onTopMenuSwtich);
        };
    }, [element]);
    useEffect(() => {
        const menuCloseListener = () => {
            setOpen(false);
        };
        const mouseEnterListener = (event) => {
            var _a;
            if (!isOpen || !((_a = element.subElements) === null || _a === void 0 ? void 0 : _a.length)) {
                return;
            }
            if (!event.detail.path.startsWith(ownPath)) {
                clearTimeout(closeTimeout);
                setOpen(false);
                return;
            }
            clearTimeout(closeTimeout);
            setOpen(true);
        };
        document.addEventListener(menuCloseEvent, menuCloseListener);
        document.addEventListener(menuElementMouseEnterEvent, mouseEnterListener);
        return () => {
            document.removeEventListener(menuCloseEvent, menuCloseListener);
            document.removeEventListener(menuElementMouseEnterEvent, mouseEnterListener);
        };
    }, [closeTimeout, element.subElements, isOpen, ownPath]);
    const onClickWrapper = (event) => {
        var _a, _b;
        let keepOpen;
        if (onOuterClick) {
            keepOpen = onOuterClick(event);
        }
        if (!onClick && !!((_a = element.subElements) === null || _a === void 0 ? void 0 : _a.length)) {
            return;
        }
        if (!((_b = element.subElements) === null || _b === void 0 ? void 0 : _b.length) && onClick) {
            const onClickResult = onClick(event);
            keepOpen = keepOpen || onClickResult;
        }
        if (!keepOpen) {
            document.dispatchEvent(PolyCustomEvent(menuCloseEvent, {}));
        }
        event.stopPropagation();
    };
    const onMouseEnter = (event) => {
        event.stopPropagation();
        if (selfRef.current && document.activeElement !== selfRef.current) {
            selfRef.current.focus();
            return;
        }
        if (element.subElements && element.subElements.length) {
            document.dispatchEvent(PolyCustomEvent(menuElementMouseEnterEvent, { detail: { path: ownPath } }));
        }
        clearTimeout(closeTimeout);
        if (isOpen) {
            return;
        }
        setOpen(true);
    };
    const onMouseLeave = (event) => {
        if (!isOpen) {
            clearTimeout(closeTimeout);
            return;
        }
        const relatedTarget = event.relatedTarget;
        const isStillSelf = relatedTarget
            && ((relatedTarget.closest
                && relatedTarget.closest('MenuElement') === selfRef.current) || checkElementNotContainedBy(relatedTarget, selfRef.current));
        if (!isStillSelf) {
            clearTimeout(closeTimeout);
            setCloseTimeout(setTimeout(() => setOpen(false), 750));
        }
    };
    const onKeyDownHorizontal = (direction) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const parentMenuElement = (_b = (_a = selfRef.current) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.closest('.MenuElement');
        // not in a sub-menu and direction is left, or there is no sub-menu
        if (!parentMenuElement && (direction === Direction.Left || !((_c = element.subElements) === null || _c === void 0 ? void 0 : _c.length))) {
            (_e = (_d = selfRef.current) === null || _d === void 0 ? void 0 : _d.closest('.MenuItem')) === null || _e === void 0 ? void 0 : _e.dispatchEvent(PolyCustomEvent(menuTopElementHorizontalEvent, { detail: { direction } }));
            return;
        }
        if (direction === Direction.Right) {
            const newFocus = (_f = selfRef.current) === null || _f === void 0 ? void 0 : _f.querySelector('.MenuElements > .MenuElement');
            (_g = newFocus) === null || _g === void 0 ? void 0 : _g.focus();
            return;
        }
        (_h = parentMenuElement) === null || _h === void 0 ? void 0 : _h.focus();
    };
    const onKeyDownVertical = (direction, currentElement) => {
        var _a, _b;
        if (document.activeElement !== selfRef.current) {
            return;
        }
        const parent = currentElement.parentElement;
        let target;
        let cycleElement = currentElement;
        do {
            target = direction === Direction.Up
                ? cycleElement.previousSibling
                : cycleElement.nextSibling;
            cycleElement = target;
        } while (cycleElement && cycleElement.classList.contains('Separator')
            && parent && parent.childNodes.length > 1);
        if (!target && direction === Direction.Up) {
            (_b = (_a = selfRef.current) === null || _a === void 0 ? void 0 : _a.closest('.MenuItem')) === null || _b === void 0 ? void 0 : _b.focus();
            return;
        }
        if (target) {
            target.focus();
        }
    };
    const onKeyDown = (event) => {
        if (event.key === 'Enter') {
            onClickWrapper(event);
            return;
        }
        onGenericKeyDown(onKeyDownHorizontal, onKeyDownVertical)(event);
    };
    return isSeparator
        ? React.createElement("hr", { className: "Separator" })
        : (React.createElement("div", { role: "menuitem", tabIndex: tabIndex, ref: selfRef, className: "MenuElement", onClick: onClickWrapper, onKeyDown: onKeyDown, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onFocus: onMouseEnter, onBlur: onMouseLeave },
            element.isChecked && React.createElement(MdCheck, { className: "SubElementsPre" }),
            React.createElement("span", { className: "ElementText" }, element.name),
            (element.subElements || []).length > 0 && React.createElement(MdKeyboardArrowRight, { className: "SubElementsPost" }),
            ((_a = element.subElements) === null || _a === void 0 ? void 0 : _a.length) === 0
                && element.postText
                && React.createElement("div", { className: "SubElementsPost text" }, element.postText),
            React.createElement("div", { className: classnames('MenuElements', 'side', { open: isOpen }) }, (_b = element.subElements) === null || _b === void 0 ? void 0 : _b.map((elem, i) => (React.createElement(MenuElement, { key: elem.name, parentPath: ownPath, element: elem, tabIndex: (tabIndex || 0) + 1 + i }))))));
};
export default MenuElement;
const MenuElementProps = PropTypes.shape({
    name: PropTypes.string.isRequired,
    isChecked: PropTypes.bool,
    postText: PropTypes.string,
    isSeparator: PropTypes.bool,
    subElements: PropTypes.array,
    onClick: PropTypes.func,
});
// eslint-disable-next-line
// @ts-ignore
MenuElementProps.subElements = PropTypes.arrayOf(MenuElementProps);
export { MenuElementProps };
//# sourceMappingURL=index.js.map